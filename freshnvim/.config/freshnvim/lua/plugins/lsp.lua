-- ---@class lazyvim.util.lsp
-- local M = {}
--
-- ---@alias lsp.Client.filter {id?: number, bufnr?: number, name?: string, method?: string, filter?:fun(client: lsp.Client):boolean}
--
-- ---@param opts? lsp.Client.filter
-- function M.get_clients(opts)
--   local ret = {} ---@type vim.lsp.Client[]
--   if vim.lsp.get_clients then
--     ret = vim.lsp.get_clients(opts)
--   else
--     ---@diagnostic disable-next-line: deprecated
--     ret = vim.lsp.get_active_clients(opts)
--     if opts and opts.method then
--       ---@param client vim.lsp.Client
--       ret = vim.tbl_filter(function(client)
--         return client.supports_method(opts.method, { bufnr = opts.bufnr })
--       end, ret)
--     end
--   end
--   return opts and opts.filter and vim.tbl_filter(opts.filter, ret) or ret
-- end
--
-- ---@param on_attach fun(client:vim.lsp.Client, buffer)
-- ---@param name? string
-- function M.on_attach(on_attach, name)
--   return vim.api.nvim_create_autocmd("LspAttach", {
--     callback = function(args)
--       local buffer = args.buf ---@type number
--       local client = vim.lsp.get_client_by_id(args.data.client_id)
--       if client and (not name or client.name == name) then
--         return on_attach(client, buffer)
--       end
--     end,
--   })
-- end
--
-- ---@type table<string, table<vim.lsp.Client, table<number, boolean>>>
-- M._supports_method = {}
--
-- function M.setup()
--   local register_capability = vim.lsp.handlers["client/registerCapability"]
--   vim.lsp.handlers["client/registerCapability"] = function(err, res, ctx)
--     ---@diagnostic disable-next-line: no-unknown
--     local ret = register_capability(err, res, ctx)
--     local client = vim.lsp.get_client_by_id(ctx.client_id)
--     if client then
--       for buffer in pairs(client.attached_buffers) do
--         vim.api.nvim_exec_autocmds("User", {
--           pattern = "LspDynamicCapability",
--           data = { client_id = client.id, buffer = buffer },
--         })
--       end
--     end
--     return ret
--   end
--   M.on_attach(M._check_methods)
--   M.on_dynamic_capability(M._check_methods)
-- end
--
-- ---@param client vim.lsp.Client
-- function M._check_methods(client, buffer)
--   -- don't trigger on invalid buffers
--   if not vim.api.nvim_buf_is_valid(buffer) then
--     return
--   end
--   -- don't trigger on non-listed buffers
--   if not vim.bo[buffer].buflisted then
--     return
--   end
--   -- don't trigger on nofile buffers
--   if vim.bo[buffer].buftype == "nofile" then
--     return
--   end
--   for method, clients in pairs(M._supports_method) do
--     clients[client] = clients[client] or {}
--     if not clients[client][buffer] then
--       if client.supports_method and client.supports_method(method, { bufnr = buffer }) then
--         clients[client][buffer] = true
--         vim.api.nvim_exec_autocmds("User", {
--           pattern = "LspSupportsMethod",
--           data = { client_id = client.id, buffer = buffer, method = method },
--         })
--       end
--     end
--   end
-- end
--
-- ---@param fn fun(client:vim.lsp.Client, buffer):boolean?
-- ---@param opts? {group?: integer}
-- function M.on_dynamic_capability(fn, opts)
--   return vim.api.nvim_create_autocmd("User", {
--     pattern = "LspDynamicCapability",
--     group = opts and opts.group or nil,
--     callback = function(args)
--       local client = vim.lsp.get_client_by_id(args.data.client_id)
--       local buffer = args.data.buffer ---@type number
--       if client then
--         return fn(client, buffer)
--       end
--     end,
--   })
-- end
--
-- ---@param method string
-- ---@param fn fun(client:vim.lsp.Client, buffer)
-- function M.on_supports_method(method, fn)
--   M._supports_method[method] = M._supports_method[method] or setmetatable({}, { __mode = "k" })
--   return vim.api.nvim_create_autocmd("User", {
--     pattern = "LspSupportsMethod",
--     callback = function(args)
--       local client = vim.lsp.get_client_by_id(args.data.client_id)
--       local buffer = args.data.buffer ---@type number
--       if client and method == args.data.method then
--         return fn(client, buffer)
--       end
--     end,
--   })
-- end
--
-- ---@return _.lspconfig.options
-- function M.get_config(server)
--   local configs = require("lspconfig.configs")
--   return rawget(configs, server)
-- end
--
-- ---@return {default_config:lspconfig.Config}
-- function M.get_raw_config(server)
--   local ok, ret = pcall(require, "lspconfig.configs." .. server)
--   if ok then
--     return ret
--   end
--   return require("lspconfig.server_configurations." .. server)
-- end
--
-- function M.is_enabled(server)
--   local c = M.get_config(server)
--   return c and c.enabled ~= false
-- end
--
-- ---@param server string
-- ---@param cond fun( root_dir, config): boolean
-- function M.disable(server, cond)
--   local util = require("lspconfig.util")
--   local def = M.get_config(server)
--   ---@diagnostic disable-next-line: undefined-field
--   def.document_config.on_new_config = util.add_hook_before(def.document_config.on_new_config, function(config, root_dir)
--     if cond(root_dir, config) then
--       config.enabled = false
--     end
--   end)
-- end
--
-- ---@param opts? LazyFormatter| {filter?: (string|lsp.Client.filter)}
-- function M.formatter(opts)
--   opts = opts or {}
--   local filter = opts.filter or {}
--   filter = type(filter) == "string" and { name = filter } or filter
--   ---@cast filter lsp.Client.filter
--   ---@type LazyFormatter
--   local ret = {
--     name = "LSP",
--     primary = true,
--     priority = 1,
--     format = function(buf)
--       M.format(LazyVim.merge({}, filter, { bufnr = buf }))
--     end,
--     sources = function(buf)
--       local clients = M.get_clients(LazyVim.merge({}, filter, { bufnr = buf }))
--       ---@param client vim.lsp.Client
--       local ret = vim.tbl_filter(function(client)
--         return client.supports_method("textDocument/formatting")
--           or client.supports_method("textDocument/rangeFormatting")
--       end, clients)
--       ---@param client vim.lsp.Client
--       return vim.tbl_map(function(client)
--         return client.name
--       end, ret)
--     end,
--   }
--   return LazyVim.merge(ret, opts) --[[@as LazyFormatter]]
-- end
--
-- ---@alias lsp.Client.format {timeout_ms?: number, format_options?: table} | lsp.Client.filter
--
-- ---@param opts? lsp.Client.format
-- function M.format(opts)
--   opts = vim.tbl_deep_extend(
--     "force",
--     {},
--     opts or {},
--     LazyVim.opts("nvim-lspconfig").format or {},
--     LazyVim.opts("conform.nvim").format or {}
--   )
--   local ok, conform = pcall(require, "conform")
--   -- use conform for formatting with LSP when available,
--   -- since it has better format diffing
--   if ok then
--     opts.formatters = {}
--     conform.format(opts)
--   else
--     vim.lsp.buf.format(opts)
--   end
-- end
--
-- M.action = setmetatable({}, {
--   __index = function(_, action)
--     return function()
--       vim.lsp.buf.code_action({
--         apply = true,
--         context = {
--           only = { action },
--           diagnostics = {},
--         },
--       })
--     end
--   end,
-- })
--
-- ---@class LspCommand: lsp.ExecuteCommandParams
-- ---@field open? boolean
-- ---@field handler? lsp.Handler
--
-- ---@param opts LspCommand
-- function M.execute(opts)
--   local params = {
--     command = opts.command,
--     arguments = opts.arguments,
--   }
--   if opts.open then
--     require("trouble").open({
--       mode = "lsp_command",
--       params = params,
--     })
--   else
--     return vim.lsp.buf_request(0, "workspace/executeCommand", params, opts.handler)
--   end
-- end
-- --
-- -- return M
return {
--   -- lspconfig
--   {
--     "neovim/nvim-lspconfig",
--     event = { "BufReadPost", "BufNewFile", "BufWritePre", "LspAttach", "VeryLazy" },
--     dependencies = {
--       "williamboman/mason.nvim",
--       { "williamboman/mason-lspconfig.nvim", config = function() end },
--     },
--     opts = function()
--       ---@class PluginLspOpts
--       local ret = {
--         -- options for vim.diagnostic.config()
--         ---@type vim.diagnostic.Opts
--         diagnostics = {
--           underline = true,
--           update_in_insert = false,
--           virtual_text = {
--             prefix = "▎", -- Could be '●', '▎', 'x', '■ ', '• ', '◆ ', '∙ ', '✗ ', '✓ ', etc.
--             severity = {
--               min = vim.diagnostic.severity.HINT,
--             },
--             format = function(diagnostic)
--               local icons = {
--                 [vim.diagnostic.severity.ERROR] = "  ",
--                 [vim.diagnostic.severity.WARN] = "  ",
--                 [vim.diagnostic.severity.HINT] = "  ",
--                 [vim.diagnostic.severity.INFO] = "  ",
--                 [vim.diagnostic.severity.HINT] = " ",
--               }
--               return icons[diagnostic.severity] .. diagnostic.message
--             end,
--           },
--           severity_sort = true,
--           signs = {
--             text = {
--               [vim.diagnostic.severity.ERROR] = " ",
--               [vim.diagnostic.severity.WARN] = " ",
--               [vim.diagnostic.severity.HINT] = " ",
--               [vim.diagnostic.severity.INFO] = " ",
--             },
--           },
--         },
--         -- Enable this to enable the builtin LSP inlay hints on Neovim >= 0.10.0
--         -- Be aware that you also will need to properly configure your LSP server to
--         -- provide the inlay hints.
--         inlay_hints = {
--           enabled = true,
--           exclude = { "vue" }, -- filetypes for which you don't want to enable inlay hints
--         },
--         -- Enable this to enable the builtin LSP code lenses on Neovim >= 0.10.0
--         -- Be aware that you also will need to properly configure your LSP server to
--         -- provide the code lenses.
--         codelens = {
--           enabled = false,
--         },
--         -- add any global capabilities here
--         capabilities = {
--           workspace = {
--             fileOperations = {
--               didRename = true,
--               willRename = true,
--             },
--           },
--         },
--         -- options for vim.lsp.buf.format
--         -- `bufnr` and `filter` is handled by the LazyVim formatter,
--         -- but can be also overridden when specified
--         format = {
--           formatting_options = nil,
--           timeout_ms = nil,
--         },
--         -- LSP Server Settings
--         ---@type lspconfig.options
--         servers = {
--           lua_ls = {
--             -- mason = false, -- set to false if you don't want this server to be installed with mason
--             -- Use this to add any additional keymaps
--             -- for specific lsp servers
--             -- ---@type LazyKeysSpec[]
--             -- keys = {},
--             settings = {
--               Lua = {
--                 workspace = {
--                   checkThirdParty = false,
--                 },
--                 codeLens = {
--                   enable = true,
--                 },
--                 completion = {
--                   callSnippet = "Replace",
--                 },
--                 doc = {
--                   privateName = { "^_" },
--                 },
--                 hint = {
--                   enable = true,
--                   setType = false,
--                   paramType = true,
--                   paramName = "Disable",
--                   semicolon = "Disable",
--                   arrayIndex = "Disable",
--                 },
--               },
--             },
--           },
--         },
--         -- you can do any additional lsp server setup here
--         -- return true if you don't want this server to be setup with lspconfig
--         ---@type table<string, fun(server:string, opts:_.lspconfig.options):boolean?>
--         setup = {
--           -- example to setup with typescript.nvim
--           -- tsserver = function(_, opts)
--           --   require("typescript").setup({ server = opts })
--           --   return true
--           -- end,
--           -- Specify * to use this function as a fallback for any server
--           -- ["*"] = function(server, opts) end,
--         },
--       }
--       return ret
--     end,
--     ---@param opts PluginLspOpts
--     config = function(_, opts)
--       -- setup autoformat
--       LazyVim.format.register(LazyVim.lsp.formatter())
--
--       -- setup keymaps
--       LazyVim.lsp.on_attach(function(client, buffer)
--         require("lazyvim.plugins.lsp.keymaps").on_attach(client, buffer)
--       end)
--
--       LazyVim.lsp.setup()
--       LazyVim.lsp.on_dynamic_capability(require("lazyvim.plugins.lsp.keymaps").on_attach)
--
--       -- diagnostics signs
--       if vim.fn.has("nvim-0.10.0") == 0 then
--         if type(opts.diagnostics.signs) ~= "boolean" then
--           for severity, icon in pairs(opts.diagnostics.signs.text) do
--             local name = vim.diagnostic.severity[severity]:lower():gsub("^%l", string.upper)
--             name = "DiagnosticSign" .. name
--             vim.fn.sign_define(name, { text = icon, texthl = name, numhl = "" })
--           end
--         end
--       end
--
--       if vim.fn.has("nvim-0.10") == 1 then
--         -- inlay hints
--         if opts.inlay_hints.enabled then
--           LazyVim.lsp.on_supports_method("textDocument/inlayHint", function(client, buffer)
--             if
--               vim.api.nvim_buf_is_valid(buffer)
--               and vim.bo[buffer].buftype == ""
--               and not vim.tbl_contains(opts.inlay_hints.exclude, vim.bo[buffer].filetype)
--             then
--               vim.lsp.inlay_hint.enable(true, { bufnr = buffer })
--             end
--           end)
--         end
--
--         -- code lens
--         if opts.codelens.enabled and vim.lsp.codelens then
--           LazyVim.lsp.on_supports_method("textDocument/codeLens", function(client, buffer)
--             vim.lsp.codelens.refresh()
--             vim.api.nvim_create_autocmd({ "BufEnter", "CursorHold", "InsertLeave" }, {
--               buffer = buffer,
--               callback = vim.lsp.codelens.refresh,
--             })
--           end)
--         end
--       end
--
--       if type(opts.diagnostics.virtual_text) == "table" and opts.diagnostics.virtual_text.prefix == "icons" then
--         opts.diagnostics.virtual_text.prefix = vim.fn.has("nvim-0.10.0") == 0 and "●"
--           or function(diagnostic)
--             local icons = LazyVim.config.icons.diagnostics
--             for d, icon in pairs(icons) do
--               if diagnostic.severity == vim.diagnostic.severity[d:upper()] then
--                 return icon
--               end
--             end
--           end
--       end
--
--       vim.diagnostic.config(vim.deepcopy(opts.diagnostics))
--
--       local servers = opts.servers
--       local has_cmp, cmp_nvim_lsp = pcall(require, "cmp_nvim_lsp")
--       local has_blink, blink = pcall(require, "blink.cmp")
--       local capabilities = vim.tbl_deep_extend(
--         "force",
--         {},
--         vim.lsp.protocol.make_client_capabilities(),
--         has_cmp and cmp_nvim_lsp.default_capabilities() or {},
--         has_blink and blink.get_lsp_capabilities() or {},
--         opts.capabilities or {}
--       )
--
--       local function setup(server)
--         local server_opts = vim.tbl_deep_extend("force", {
--           capabilities = vim.deepcopy(capabilities),
--         }, servers[server] or {})
--         if server_opts.enabled == false then
--           return
--         end
--
--         if opts.setup[server] then
--           if opts.setup[server](server, server_opts) then
--             return
--           end
--         elseif opts.setup["*"] then
--           if opts.setup["*"](server, server_opts) then
--             return
--           end
--         end
--         require("lspconfig")[server].setup(server_opts)
--       end
--
--       -- get all the servers that are available through mason-lspconfig
--       local have_mason, mlsp = pcall(require, "mason-lspconfig")
--       local all_mslp_servers = {}
--       if have_mason then
--         all_mslp_servers = vim.tbl_keys(require("mason-lspconfig.mappings.server").lspconfig_to_package)
--       end
--
--       local ensure_installed = {} ---@type string[]
--       for server, server_opts in pairs(servers) do
--         if server_opts then
--           server_opts = server_opts == true and {} or server_opts
--           if server_opts.enabled ~= false then
--             -- run manual setup if mason=false or if this is a server that cannot be installed with mason-lspconfig
--             if server_opts.mason == false or not vim.tbl_contains(all_mslp_servers, server) then
--               setup(server)
--             else
--               ensure_installed[#ensure_installed + 1] = server
--             end
--           end
--         end
--       end
--
--       if have_mason then
--         mlsp.setup({
--           ensure_installed = vim.tbl_deep_extend(
--             "force",
--             ensure_installed,
--             LazyVim.opts("mason-lspconfig.nvim").ensure_installed or {}
--           ),
--           handlers = { setup },
--         })
--       end
--
--       if LazyVim.lsp.is_enabled("denols") and LazyVim.lsp.is_enabled("vtsls") then
--         local is_deno = require("lspconfig.util").root_pattern("deno.json", "deno.jsonc")
--         LazyVim.lsp.disable("vtsls", is_deno)
--         LazyVim.lsp.disable("denols", function(root_dir, config)
--           if not is_deno(root_dir) then
--             config.settings.deno.enable = false
--           end
--           return false
--         end)
--       end
--     end,
--   },
--
--   -- cmdline tools and lsp servers
--   {
--
--     "williamboman/mason.nvim",
--     cmd = "Mason",
--     keys = { { "<leader>cm", "<cmd>Mason<cr>", desc = "Mason" } },
--     build = ":MasonUpdate",
--     opts_extend = { "ensure_installed" },
--     opts = {
--       ensure_installed = {
--         "stylua",
--         "shfmt",
--       },
--     },
--     ---@param opts MasonSettings | {ensure_installed: string[]}
--     config = function(_, opts)
--       require("mason").setup(opts)
--       local mr = require("mason-registry")
--       mr:on("package:install:success", function()
--         vim.defer_fn(function()
--           -- trigger FileType event to possibly load this newly installed LSP server
--           require("lazy.core.handler.event").trigger({
--             event = "FileType",
--             buf = vim.api.nvim_get_current_buf(),
--           })
--         end, 100)
--       end)
--
--       mr.refresh(function()
--         for _, tool in ipairs(opts.ensure_installed) do
--           local p = mr.get_package(tool)
--           if not p:is_installed() then
--             p:install()
--           end
--         end
--       end)
--     end,
--   },
}
